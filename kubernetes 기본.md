<a href="https://github.com/och5351/cluster#readme">메인으로</a>

<a id="home1"></a>

# 쿠버네티스 아키텍처

<br>
<div align="center">
<img src="https://user-images.githubusercontent.com/45858414/128103567-af756b41-4566-4ebd-a43a-e733890f81ba.png"  width="70%" height="70%"/>
</div>

* SRE : Site Reliability Engineer (사이트 신뢰성 엔지니어)의 약어로, 운영 업무만이 아닌 운영의 신뢰성 향상, 자동화를 목적으로 하는 프로그램 개발 담당 엔지니어
* 마스터는 k8s 클러스터의 단일 장애점이 되지 않도록 다중화 할 수 있다.
* 쿠버네티스에 연결 가능한 노드의 개수는 버전 1.11 기준으로 5,000대 가능.

<br><br>

## 목차

- [Kubernetes 의 장점](#1)
- [](#2)


<br><br>
<a id="1"></a> 

# Kubernetes 의 장점

<br><br><br>

### 1. 애플리케이션의 잦고, 빠른 출시 시기

<br>
쿠버네티스의 롤아웃, 롤백 기능을 통하여 새로운 기능을 자주 출시하고 버그 수정을 긴급하게 투입하는 것과 같이 민감한 작업을 안전하게 자동화 해 준다.
정식 운영 중인 서비스의 앱 컨테이너를 무정지로 교체할 수 있고 교체 중 발생하는 성능 저하와 프로그램 충돌로 인한 서비스 정지를 막기 위해 컨테이너 교체 정책을 설정할 수 있다.

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 2. 무정지 서비스

<br>
쿠버네티스의 자기 회복 기능을 통하여 무정지 서비스 운영을 도와준다. 응답이 없어진 컨테이너를 재기동하며, 쿠버네티스 클러스터 내에 지정한 수만큼 컨테이너가 돌도록 관리 가능

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 3. 초기 비용을 낮추고 비지니스 상황에 맞게 규모를 조정

<br>
컨테이너 기술은 앱과 실행 환경을 하나로 묶어서 배포할 수 있게 해준다.그리고 쿠버네티스는 복수의 노드 위에서 컨테이너가 돌아갈 수 있도록 해준다.
이 때 클러스터의 각 노드들이 똑같은 스펙일 필요가 없으며, 비지니스의 초기 단계에서는 스펙이 낮고 저렴한 가상ㅎ서버를 사용하다가, 비지니스가 확대되면 고성능의 가상 서버나 물리 서버를 투입시키는 
전략을 취하여 초기 비용을 낮출 수 있다.

k8s 클러스터 내에서 컨테이너를 다른 노드로 옮기기 위해서는 먼저 해당 노드에 스케줄이 되지 않도록 설정하고, 해당 노드의 모든 컨테이너를 추방시키면 된다.

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 4. 쿠버네티스와 외부 서비스와의 연동

<br>
데이터베이스에 대한 컨태이너화는 신중하게 접근할 필요가 있다.(컨테이너는 태생적으로 언제든지 재시작될 수 있는 일시적인 존재로 상태를 포함하지 않는 것을 전제로 하기 때문)
이 때 한이브리드한 시스템을 구축하는 것이 한 가지 대안이 될 수 있다. 예를 들면, 클라우드의 DBaaS(Database as a Service)나 온프레미스에서 관리하는 데이터베이스와 연동하는 것.
이런한 연동을 위해 쿠버네티스는 외부 서비스를 내부 DBS에 등록하는 기능 제공

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 5. 개발 환경과 운영 환경의 분리

<br>
컨테이너의 개발이 완료되어 테스트까지 끝났다면 정식 서비스 때 배포하기 전까지는 이미지를 다시 빌드하지 않는 것이 좋다. (테스트로 검증되지 않은 기능이 포함될 여지가 있기 때문)
운영 환경에서 사용하는 엔드포인트나 인증 정보는 테스트 환경과 다르기 마련이며, 데이터베이스의 접속 주소나 HTTPS를 위한 인증서 등이 다르다.

쿠버네티스에서는 클러스터를 여러 개의 가상 환경으로 분할 하는 것이 가능. 그리고 각각의 가상환경에 설정 파일, 보안이 필요한 인증서나 비밀번호를 저장할 수 있다.
즉, 테스트가 완료된 컨테이너의 이미지를 그대로 정식 운영 환경에 배포할 수 있다.

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 6. 온프레미스와 클라우드 위에 구축

<br>
대형 클라우드 업체들은 EKS(AWS), AKS(Azure), IKS(IBM Cloud)와 같은 쿠버네티스 서비스를 제공한다. 쿠버네티스는 인프라의 복잡성을 감추며, 일관된 인터페이스로 다룰 수 있도록 설계되었다.

온프레미스와 클라우드 환경에서 동일한 인터페이스로 조작하며 운영할 수 있다.

<br>

<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 7. 애플리케이션 중심의 오케스트레이션

<br>
애플리케이션 개발자가 YAML 파일을 기술하여 쿠버네티스에 제출하면 로드밸런서, 저장소, 네트워크, 런타임 등의 환경이 구성된다.

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 8. 특정 기업에 종속되지 않는 표준 기술

<br>
쿠버네티스 프로젝트는 원래 구글에서 시작되었지만, CNCF에 기증되어 오픈 소스 프로젝트로 운영되고 있다. 170여 개의 회사가 참가하고 있기 때문에 특정 회사에 종속되지 않은 포준 기술로 자리 잡았음.

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

### 9. 서버들의 가동률 높이기

<br>
CPU 사용률이 낮은 서버가 많은 것은 퍼블릭 클라우드에서도 온프레미스에서도 바람직하지 않다. 한편, 쿠버네티스에서 사용되는 컨테이너 기술은 애플리케이션이 정해진 서버에서 돌지 않아도 된다는 자유를 제공한다.
또한, CPU 사용 시간이나 메모리 요구량도 간단히 제어할 수 있다.

이 기술 덕분에 쿠버네티스는 가동률이 적은 서버의 애플리케이션을 한 곳에 모을 수 있다. 그래서 서버의 CPU 가동률을 높게 유지하면서도 안정적으로 서비스를 제공한다는 상반되는 요구사항을 충족시킬 수 있는 것.

<br>
<div align="right"> 

[목차로](#home1) 
</div><br><br>

<br><br>
<a id="2"></a> 

# Kubernetes 세부 아키텍처

<br>

Kubernetes는 Master와 Node로 구성 된다.


### 출처: 15단계로 배우는 도커와 쿠버네티스